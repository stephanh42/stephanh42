<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="theme.css">
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
  <title>Stephan's Blog</title>
</head>
<body>
  <h1>Stephan's Blog</h1>
  <article class="blog">
  <header>
  <h1>Numbers in JavaScript</h1>
  </header>

  Numbers in JavaScript have a number of particular properties.
  In particular, there are a number of special "Numbers" which aren't ordinarily considered numbers.

  <table>
  <tr> <th> Special number</th> <th>  Description </th> </tr>
  <tr> <td> <code>Infinity</code></td> <td>  The mathematical ∞, larger than any number. </td> </tr>
  <tr> <td> <code>-Infinity</code></td> <td>  The mathematical -∞, smaller than any number. </td> </tr>
  <tr> <td> <code>NaN</code></td> <td>  Not a Number, but nevertheless <code>typeof NaN === "number"</code>. </td> </tr>
  <tr> <td> <code>-0</code></td> <td>  Under normal mathematics this would be equal to 0. <br> But while <code>0 === -0</code>, <code>1/0 === Infinity</code> and <code>1/-0 === -Infinity<code>. </td> </tr>
  </table>

 <p>However, even "normal" numbers have some peculiar properties.
 <p><code>0.1 + 0.2</code>
 <br>⇒ <samp>0.30000000000000004</samp>
 <p>
 Mmmm. That seems a bit off.
 <p>
 Most of the rest of this post will be about why we get this result, and some kind of apology
 why that behavior is kinda OK in most cases. But first things first...

 <div class="shoutout">When you are working with money, this is certainly not OK!</div>
 <p>
 I mean, the pennies don't add up! Can there be any disaster greater in accounting than pennies which don't add up?
 <p>
 Now I have some amazing confession to make. The built-in JavaScript number type is, for exactly the reason we have seen above,
 <em>unsuitable</em> to represent monetary data. And for kicks, JavaScript also doesn't provide another datatype
 which would be suitable. So that leaves approximately one billion web-shop front-ends to invent their own solution to this
 problem. 
 <p>
 You may now want pick up your jaw from the carpet again.
 <p>
So what to do if you have to deal with money? Well, I would recommend using an external library such as <a href="http://mikemcl.github.io/decimal.js-light/">Decimal.js</a>. With this library, you can do the following:

<p><code>Decimal("0.1").add(Decimal("0.2")).toString()</code>
<br>⇒ <samp>"0.3"</samp>
<p>
OK, so the syntax looks terrible but we get the correct result.
Also note that we directly convert from string to Decimal, and directly back from Decimal to string.
So no temporary results as number. This is important to avoid rounding issues.

<h2>Alternative solutions which are not so hot</h2>

If you hang out on stackunderflow or some other wisdom-of-the-masses site, you may get the following recommendations instead.
<ol>
<li> Use <code>amount.toFixed(2)</code> to get the end result.</li>
<li> Do all your accounting in pennies/cents </li>
<li> Periodically round back to "entire" cents using <code>Math.round(amount*100)/100</code>.
</ol>
Of these, the first gets special mention in not even really dealing with the problem but basically just papering over it. Internally the stored number is still off. The other two solutions can be summarized as "let's build Decimal.js ourselves but with more bugs". This may be an educative exercise for the programmer without deadlines, but I'd recommend that if it is about actual money you don't invent this wheel and use something like Decimal.js.
</article>

<h2>How do JavaScript numbers work anyway?</h2>

OK, so now we have the financial data people out of the room, let's see how JavaScript numbers
actually work. JavaScript uses a number system standard known as
<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE Standard for Floating-Point Arithmetic</a>, or IEEE 754 among friends. In fact, IEEE 754 describes multiple number systems; the one used by JavaScript is called binary64. In binary64, a number is stored as 64 bits and it is stored as a binary (base-2) number, as opposed to some decimal (base-10) representation.

<figure>
<img src="fpjs-figure0.svg">
<figcaption>The layout of a JavaScript number.</figcaption>
</figure>

So we have three fields, each of which can be considered an unsigned integer.
Now, given those three numbers, how do we get back to our original number \(x\)?

<ol>
<li> First we take the fraction \(F\) and divide by \(2^{52}\). That produces a number \(x_1\). Note that \(0 \le x_1 < 1\).
<li> Add 1 to \(x_1\), producing a number \(x_2\) so that \(1 \le x_2 < 2\).
<li> Then multiply \(x_2\) with the number \(2^{E-1023}\), producing a number \(x_3\). <br>
    Note that if \(E < 1023 \) then we are multiplying with a number smaller than 1, so we may end up with a fractional result.
<li> Finally, if \(S = 0\) then \( = x_3\), and if \(S = 1\) then \(x = -x_3\).
</ol>

This can be summarized in a single formula.

<figure>
\[ x = (-1)^S \cdot (1 + \frac{F}{2^{52}}) \cdot 2^{E - 1023} \]
</figure>

Note that there are special rules for \(E = 0\) and \(E = 2047\) (the maximum value for \(E\)).

<table>
<tr><th>\(S\)</th> <th>\(E\)</th> <th>\(F\)</th> <th>\(x\)</th> <th>note</th> </tr>
<tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> </tr>
<tr> <td>1</td> <td>0</td> <td>0</td> <td>-0</td> <td>a distinct value from 0</td> </tr>
<tr> <td>0</td> <td>2047</td> <td>0</td> <td><code>Infinity</code></td> </tr>
<tr> <td>1</td> <td>2047</td> <td>0</td> <td><code>-Infinity</code></td> </tr>
<tr> <td>0 or 1</td> <td>2047</td> <td>\(\ne 0\)</td> <td><code>NaN</code></td> <td>many possible representations</td></tr>
<tr> <td>0 or 1</td> <td>0</td> <td>\(\ne 0\)</td> <td>\({(-1)}^S \cdot F \cdot 2^{-1074}\)</td> <td>so-called <em><a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a></em> numbers</td></tr>
</table>

The important take-away is that, with these rules, there is no way to represent the number 0.1 exactly. In fact, numbers like \(1/3\) or \(1/5\) also cannot be represented exactly. The only fractions which can possibly be represented exactly are ones where the denominator is a power of two. So \(1/2\) and \(3/4\) can be represented exactly, but 0.1, 0.2 and 0.3 (a.k.a. \(1/10\), \(1/5\) and \(3/10\)) cannot.

<h2>So what happens if I enter 0.1 on the JavaScript console?</h2>

You enter <code>0.1</code> in the JavaScript console and get back <samp>0.1</samp>.
How is this possible?
<p>
Well, what really happens is that 0.1 is first rounded to the nearest number which <em>can</em>
be represented. That is the number with 
S = 0, E = 1019 and  F= 2702159776422298. In decimal, it is the number
<figure>
0.1000000000000000055511151231257827021181583404541015625
</figure>
So why doesn't the console print back that number?
<p>
Well, the thinking was that printing back the above number would be a bit excessive. So there is actually a <em>second</em> approximation, a step which I call <em>un-rounding</em>. We are going to round the number to a minimum number of (decimal) digits so that, if we convert it back to a JavaScript floating-point number,
it is still the same number. This is kind of the opposite operation of the rounding we do when converting from decimal to binary.
<p>
Un-rounding the ugly number above will again give 0.1. (Try entering it in a JavaScript console.)


<h2>Computing S, E and F in JavaScript</h2>

Here is some code to find S, E and F for an arbitrary JavaScript number.

<pre class="code">
function decomposeNumber(x) {
  const dataView = new DataView(new ArrayBuffer(8));
  dataView.setFloat64(0, x);
  const hi = dataView.getUint32(0);
  const lo = dataView.getUint32(4);
  return {
    S: hi >>> 31, 
    E: (hi << 1) >>> 21, 
    F: (hi & ((1<<20)-1)) * 2**32 + lo
  };
}
</pre>


</body>
</html>
